用一个烦恼代替另一个烦恼


----
    主要算法，预排序o，高斯消去法？，平衡查找树？，堆排序？，霍纳法则和二进制幂？，
            问题化简（线性规划和，化简为图问题）？。

        预排序问题：检查数组的元素的唯一性，模式计算（最经常出现的数值），查找问题，
                    这些问题都是可以通过先排序再统计

        高斯消去法：暂且跳过

        平衡查找树：（代码是抄的 https://www.programiz.com/dsa/avl-tree ）

                    节点高度，表示从该节点到它最远的叶子节点的距离，也就是边的数量

                    空节点，即没有值的节点的（节点的）高度为-1，平衡因子为0
                    叶子节点，即没有子节点的（节点的）高度为0


                    AVL树：（https://www.hello-algo.com/chapter_tree/avl_tree/#5）

                        插入和删除时，和一般二叉树一样，只是在最后进行旋转来平衡就行。

                        旋转条件：

                            失衡节点的平衡因子              子节点的平衡因子        采用的旋转
                            >1(左偏树)                      >=0                     右旋
                            >1(左偏树)                      <0                      先左后右
                            <-1(右偏树)                     <=0                     左旋
                            <-1(右偏树)                     >0                      先右后左


                    2-3树：（https://www.youtube.com/watch?v=bhKixY-cZHE）
                        一个节点有两个值时，左边的节点小于这两个值，中间的节点位于两个值之间，右边的节点大于这两个值。

                        插入：一个值的时候，先遍历找到合适的位置，如果合适容量，则插入，如果容量已满
                            则上提，变为单节点2值-3节点的树，如果这时候插入，则放入叶子节点，
                            如果叶子节点已满，则上提，但这时候根节点也已经满了，


        堆排序：
                二叉堆是一个完全二叉树，字节点不得大于父节点。
                
                插入：放到数组末尾，然后与父节点比较
                删除：只能删除根节点，然后把最后一个节点拿到根节点，然后向下比较。


        霍纳法则和二进制幂：暂且跳过


        问题化简：
                线性规划：

                化简为图：
