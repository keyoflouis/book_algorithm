不断分开解决小规模的问题，来解决问题


----
本身对分治的思想本身已经很熟了，任何关于几何计算的问题，用画图来理解是最合适的。

本章重点算法： 归并排序o，快速排序o，二叉树的遍历？，大整数乘法和strassen矩阵乘x，最近对？，凸包？

----
    归并排序：
            第一次写错的地方，
            sizeof(r-l+1) sizeof(int)*(r-l+1); 
            初始化aux的时候使用的aux[i]而不是aux[i-l];
            i = l 写成了i=数字1；
            i不是>= mid,而是i>mid
            j不是>=r，而是j>r
            aux[i-l] < aux[i-l]而不是,aux[j-l]
            计算mid的时候不需要+1
            主函数调用mergeSort的n，数错了
        （可以考虑并发版本的归并排序）

    快速排序：
            

    二叉树的遍历：
            前序遍历，先访问自己（根节点），在访问左子树，然后是右子树。
            中序遍历，先访问左子树，再访问自己（根节点），然后是右子树。
            后序遍历，先访问左子树，然后是右子树，然后是自己（根节点）。

    分治最近对（计算几何）：
            分成左右两半：
            	将点集按照x坐标分为两个子集，每个子集包含一半的点。
            得到各自两半最近点的距离：
            	 rd  和 ld ：递归地在两个子集中分别找到最近点对，及其距离。
            设定一个距离 L ：
            	取 rd 和 ld 中较小的一个作为 L ，这代表了当前已知的最近点对的距离。
            在中线附近寻找可能的最近点对：
            	将位于 midx - L  midx + L 距离内的所有点传入A数组，这些点可能构成更近的点对。
            对点进行y轴排序并计算距离：
            	对A数组按照y坐标排序，然后对每个点，只考虑后面的 且y轴差距在  L  范围内的点，计算它们之间的距离。
            
    凸包问题：
            
