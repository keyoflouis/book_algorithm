直接从算法的时间复杂度，用各种思想来优化算法也是一个很好的思路。


减治法
    从小规模的相同的问题来解决，建立小规模和大规模 （相同问题的联系）,一般有减常量，常量因子，可变规模

常见算法有，
    插入排序o，希尔排序x，拓扑排序?，生成排列?，生成子集? ，
    减常因子的算法：折半查找o，假币问题?，俄式乘法?，约瑟夫斯问题?
    减可变规模的算法：计算中值和选择问题?，插值查找?，二叉树的查找和插入?，nim游戏?


-----
    拓扑排序：用于判断各个先决条件是否冲突，比如在cpp中头文件互相包含。
            实现：（1）基于DFS 用栈或队列来追踪节点的先后顺序 .（2）不断删除无输入的节点
            目前实现了基于DFS的拓扑排序，在代码中遗留了基于减治的版本

    生成排列：给定一个数字，然后生成这个数字以下的全排列 
            johnson-trotter ，首先生成一个顺序递增的序列。（排序可以做到），箭头表示是关键。