直接从算法的时间复杂度，用各种思想来优化算法也是一个很好的思路。


减治法
    从小规模的相同的问题来解决，建立小规模和大规模 （相同问题的联系）,一般有减常量，常量因子，可变规模

常见算法有，
    插入排序o，希尔排序x，拓扑排序o，生成排列o，生成子集o ，
    减常因子的算法：折半查找o，假币问题o，俄式乘法o，约瑟夫斯问题o
    减可变规模的算法：计算中值和选择问题o，插值查找?，二叉树的查找和插入?，nim游戏?


-----
    拓扑排序：用于判断各个先决条件是否冲突，比如在cpp中头文件互相包含。
            实现：（1）基于DFS 用栈或队列来追踪节点的先后顺序 .（2）不断删除无输入的节点
            目前实现了基于DFS的拓扑排序，在代码中遗留了基于减治的版本

    生成排列：给定一个数字，然后生成这个数字以下的全排列 
            johnson-trotter ，根据一个有序序列，找到最大的移动元素，然后与箭头指向的相邻的元素交换，然后反转所有比当前最大移动元素还要大的元素的箭头
                            减一思想，生成一个 0...n 的全排列，只要生成n-1个排序后，将n从左向右插入即可
    生成子集：
            用减治的思想来迭代生成格雷码， n==1 时，返回L1 ={“0”，“1”}，
            后面的代码只需要插入 “1” 和“0”到这个L1即可，

    假币问题：这里我用的分治，把所有硬币分为两堆。
    
    俄式乘法：用书上的例子照着抄就行

    约瑟夫问题：一圈人，数123，数到3杀一个，直到只有一个的时候。

    计算中值和选择问题：lomuto划分和快速选择，基于划分的中值和选择有大问题（在实现快排的时候也许要写一下lomuto）。

    插值查找：计算可能在的位置（预估值），如果大于预计值则将low改为预计值+1，如果小于预计值则将high改为预计值-1

    二叉树的查找与插入：

    nim游戏：暂且跳过。