关于kraskal

有许多应用要求把一个n元素集合 S 动态划分为一系列不相交的子集 S1,S2,,Sk,Kruskal算法就是其中的一种。在把它们初始化为n个单元素子集以后，每一个子集都包含了S中一个不同的元素，然后可以对这些子集做一系列求并集和查找的混合操作。(请注意在任何这种操作序列中，求并集操作的次数不会超过n-1次，因为每次求并都至少会把子集的大小增加 1，而在整个集合 S 中只有n个元素。)因此，我们在这里涉及的是一种抽象数据类型，这种数据类型是由某个有限集的一系列不相交子集以及下面这些操作构成的。makeset(x)生成一个单元素集合{x}。假设这个操作对集合 S的每一个元素只能应用一次。find(x)返回一个包含x的子集。union(x,y)构造分别包含x和的不相交子集Sx和Sy的并集并把它添加到子集的集合中，以代替被删除后的Sx和Sy。

这种抽象数据类型的大多数实现都会使用每一个不相交子集中的一个元素作为子集的代表(representative)。有些实现对于这样一种代表没有强加任何的特定约束。其他的实现则
有一些特定的约束，例如要求每个子集中的最小元素作为子集的代表。而且，这些算法常常会假设集合的元素是整数(或者可以映射为整数)。实现这种数据结构有两种主要的做法。第一种称为快速查找quick find)，其查找操作的时间效率是最优的;第二种称为快速求并(quick union)，其求并集操作是最优的。快速查找要使用一个数组，并以集合S中的元素来索引数组，数组中的值指出了包含这些元素的子集代表。每一个子集都是由链表实现的，表头包含了指向表头和表尾元素的指针以及表中的元素个数(图 9.7 给出了一个例子)。根据这种方案，makeset(x)的实现要求把代表数组中相应元素的值赋为x，并把相应的链表初始化为值为x的单节点链表。这种操作的时间效率显然属于O(1)，因此初始化n个单元素子集属于On,find(x)的效率也是属于O1:我们需要做的就是从代表数组中取出x的代表。union(x,)的执行时间就要长一些。一种直接的做法就是把y的列表添加到x列表的后面，对于y列表中的所有元素更新它们的代表信息，然后再删除y的列表。然而，很容易验证，如果以这种算法进行一系列的求并集操作,他的运行时间属于On的平方

有一种简单的方法可以改进一系列union 操作的总效率，即总是将两个链表中较短的表添加到较长的表之后，而顺序则是无所谓的。当然，前提是每个链表的大小是已知的，例如可以在表头中存储元素的数量。这种改进称为按大小求并(union by size)。虽然这不会改善一次union 操作的最差效率(它还是属于On))，但对于一系列按大小求并的操作，可以证明任何合理的操作序列的最差效率是属于O(mlogn)的。
下面是该断言的一个证明。设要对集合S中的子集进行处理，ai 是S中的一个元素，在一系列按大小求并的操作中，ai 的代表被更新的次数为 Ai。如果集合S有n个元素，Ai最多能达到多大?每次更新ai的代表时，ai总是属于求并集的两个字集中较小的子集，而并集的规模至少是包含 ai的子集的两倍大。因此，当ai的代表第一次被更新时，结果集至少包含 2个元素;当第二次被更新时，结果集至少包含 4 个元素;推而广之，当它被第 Ai次更新时，结果集将至少包含2的Ai次方 个元素。因为整个集合 S只有n个元素，而2的Ai次方 <=n，因此A
i<= log2 n。所以，对于S中的所有 n 个元素来说，代表可能被更新的总次数不会超过n log2 n。因此，对于按大小求并，不超过 n-1次求并和 m 次查找的操作序列的时间效率属于O(nlogn+m)。
第二种不相交子集的实现方法是快速求并，它用一棵有根树来表示每一个子集。树中的节点包含子集中的元素(每个节点一个元素)，而根中的元素就被当作该子集的代表:树中的边从子女指向它们的父母,此外，还要维护一个从集合元素到树中节点的映射例如用一个指针数组来实现。根据这种实现，makeset(x)需要创建一棵单节点的树，这是一个O(1)的操作，因此初始化n棵单节点树是0(n)的操作。unio(x,y)的实现方法是把y的根附加到x树的根上(并把指向y树的根的指针置为空，来把y树删除)。这种操作的时间效率显然属于(1)。find(x)的实现方法是沿着一条指针链，从包含x的节点开始找到树的根(根中元素作为子集代表就是该函数的返回值)。相应地，单次 find 操作的时间效率属于 O(n)，因为一表示子集的树可以退化为一个n节点的链表。

这种时间效率是可以改进的。一种直接的做法就是在执行 union 操作时总是把较小的树附加到较大树的根上，而次序是无关紧要的。既可以用节点的个数(这个版本称为按大小求井)，也可以用树的高度(这个版本称为按层数求并，即 union by rank)来度量树的大小当然，它们都需要存储树中每一个节点的信息，对这两种方式而言分别是节点子孙的数量以及以该节点为根的子树高度。不难证明，在任何一种情况下树的高度都会是对数级的，这就使得每次执行查找的时间不超过 O(lg n)。因此，对于快速求并来说，不超过n-1次求并和m 次查找的操作序列的时间效率属于 O(n +m logn)。实际上，两种类型的快速求并都可以和路径压缩(path compression)法结合，以获得更好的效率。这种改进使得查找操作执行过程中遇到的每一个节点都直接指向树的根(图 9.9)。据一个十分复杂的分析(这个分析已经超出了本书的范围，详情参见[Tar84])，经过类似这种技术的改进，不超过n-1次求并和m 次查找的操作序列的时间效率和线性效率只有很小的差异。